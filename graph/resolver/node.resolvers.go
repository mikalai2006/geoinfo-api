package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/mikalai2006/geoinfo-api/graph/generated"
	"github.com/mikalai2006/geoinfo-api/graph/loaders"
	"github.com/mikalai2006/geoinfo-api/graph/model"
	"github.com/mikalai2006/geoinfo-api/internal/domain"
	"github.com/mikalai2006/geoinfo-api/internal/middleware"
	"github.com/mikalai2006/geoinfo-api/internal/repository"
	"github.com/mikalai2006/geoinfo-api/internal/utils"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// CreateNode is the resolver for the createNode field.
func (r *mutationResolver) CreateNode(ctx context.Context, input model.NewNode) (*model.Node, error) {
	return &model.Node{ID: primitive.NewObjectID(), Lat: input.Lat, Lon: input.Lon, OsmID: input.OsmID}, nil
}

// ID is the resolver for the _id field.
func (r *nodeResolver) ID(ctx context.Context, obj *model.Node) (string, error) {
	return obj.ID.Hex(), nil
}

// UserID is the resolver for the userId field.
func (r *nodeResolver) UserID(ctx context.Context, obj *model.Node) (string, error) {
	return obj.UserID.Hex(), nil
}

// Data is the resolver for the data field.
func (r *nodeResolver) Data(ctx context.Context, obj *model.Node) ([]*model.Nodedata, error) {
	gc, err := utils.GinContextFromContext(ctx)
	lang := gc.MustGet("i18nLocale").(string)
	if err != nil {
		return nil, err
	}

	result, err := r.Repo.Nodedata.GqlGetNodedatas(domain.RequestParams{
		// Options: domain.Options{Limit: 10},
		Filter: bson.M{"node_id": obj.ID, "status": bson.M{"$gt": 0}},
		Lang:   lang,
	})
	if err != nil {
		return result, err
	}
	// result, errs := loaders.GetTags(ctx, obj.Tags)
	// if len(errs) > 0 {
	// 	fmt.Println("Error:", errs)
	// }
	return result, nil
}

// TagsData is the resolver for the tagsData field.
func (r *nodeResolver) TagsData(ctx context.Context, obj *model.Node) ([]*model.Tag, error) {
	gc, err := utils.GinContextFromContext(ctx)
	lang := gc.MustGet("i18nLocale").(string)
	if err != nil {
		return nil, err
	}

	listIDs := []primitive.ObjectID{}

	// TODO
	// for i := range obj.Tags {
	// 	uIDPrimitive, err := primitive.ObjectIDFromHex(obj.Tags[i])
	// 	if err != nil {
	// 		return []*model.Tag{}, err
	// 	}
	// 	listIDs = append(listIDs, uIDPrimitive)
	// }

	result, err := r.Repo.Tag.GqlGetTags(domain.RequestParams{
		// Options: domain.Options{Limit: 10},
		Filter: bson.M{"_id": bson.M{"$in": listIDs}},
		Lang:   lang,
	})
	if err != nil {
		return result, err
	}
	// result, errs := loaders.GetTags(ctx, obj.Tags)
	// if len(errs) > 0 {
	// 	fmt.Println("Error:", errs)
	// }
	return result, nil
}

// AmenityID is the resolver for the amenityId field.
func (r *nodeResolver) AmenityID(ctx context.Context, obj *model.Node) (string, error) {
	return obj.ID.Hex(), nil
}

// Props is the resolver for the props field.
func (r *nodeResolver) Props(ctx context.Context, obj *model.Node) (interface{}, error) {
	return obj.Props, nil
}

// User is the resolver for the user field.
func (r *nodeResolver) User(ctx context.Context, obj *model.Node) (*model.User, error) {
	var result *model.User
	gc, err := utils.GinContextFromContext(ctx)
	if err != nil {
		return result, err
	}
	lang := gc.MustGet("i18nLocale").(string)

	filter := bson.D{}
	filter = append(filter, bson.E{"_id", obj.UserID})

	allItems, err := r.Repo.User.GqlGetUsers(domain.RequestParams{
		Options: domain.Options{Limit: 1, Skip: 0},
		Filter:  filter,
		Lang:    lang,
	})
	if err != nil {
		return result, err
	}

	if len(allItems) > 0 {
		result = allItems[0]
	}

	return result, nil
}

// Like is the resolver for the like field.
func (r *nodeResolver) Like(ctx context.Context, obj *model.Node) (*model.NodeLike, error) {
	gc, err := utils.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}
	userID, err := middleware.GetUID(gc)
	// if err != nil {
	// 	return nil, err
	// }
	ilikes, err := r.Repo.Like.GqlGetLikes(domain.RequestParams{
		Options: domain.Options{Limit: 10},
		Filter:  bson.D{{"node_id", obj.ID}},
	})
	if err != nil {
		return nil, err
	}

	l := 0
	dl := 0
	iamlike := model.Like{}
	for _, like := range ilikes {
		if like.Status == 1 {
			l = l + 1
		} else if like.Status == -1 {
			dl = dl + 1
		}

		if like.UserID.Hex() == userID {
			iamlike = *like
		}
	}

	result := model.NodeLike{
		Like:  l,
		Dlike: dl,
		Ilike: iamlike,
	}

	return &result, nil
}

// Reviews is the resolver for the reviews field.
func (r *nodeResolver) Reviews(ctx context.Context, obj *model.Node) ([]*model.Review, error) {
	result, err := r.Repo.Review.GqlGetReviews(domain.RequestParams{
		Options: domain.Options{Limit: 10},
		Filter:  bson.D{{"osm_id", obj.OsmID}},
	})
	if err != nil {
		return result, err
	}
	return result, nil
}

// Address is the resolver for the address field.
func (r *nodeResolver) Address(ctx context.Context, obj *model.Node) (*model.Address, error) {
	// result, err := r.Repo.Address.GqlGetAdresses(domain.RequestParams{
	// 	Options: domain.Options{Limit: 1},
	// 	Filter:  bson.D{{"osm_id", obj.OsmID}},
	// })
	result, err := loaders.GetAddress(ctx, obj.OsmID)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ReviewsInfo is the resolver for the reviewsInfo field.
func (r *nodeResolver) ReviewsInfo(ctx context.Context, obj *model.Node) (*model.ReviewInfo, error) {
	var result model.ReviewInfo

	count, err := r.Repo.Review.GqlGetCountReviews(domain.RequestParams{Filter: bson.D{{"osm_id", obj.OsmID}}})
	if err != nil {
		return &result, err
	}
	result = *count

	return &result, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *nodeResolver) CreatedAt(ctx context.Context, obj *model.Node) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *nodeResolver) UpdatedAt(ctx context.Context, obj *model.Node) (string, error) {
	return obj.UpdatedAt.String(), nil
}

// Nodes is the resolver for the nodes field.
func (r *queryResolver) Nodes(ctx context.Context, first *int, after *string, limit *int, skip *int, input *model.ParamsNode) (*model.PaginationNode, error) {
	var results *model.PaginationNode

	options := options.Find()
	//options.SetSort(bson.D{{"createdAt", 1}})
	if limit != nil {
		options.SetLimit(int64(*limit))
	}
	options.SetSkip(int64(*skip))
	q := bson.D{}
	if after != nil {
		// idPrimitive, err := primitive.ObjectIDFromHex(*after)
		// if err != nil {
		// 	return results, err
		// }

		// q = append(q, bson.E{"_id", bson.D{{"$lt", idPrimitive}}})
		// q = append(q, bson.E{"createdAt", bson.D{{"$lt", &after}}})
	}

	if input.LatA != nil {
		q = append(q, bson.E{"lat", bson.D{{"$gt", input.LatA}}})
	}
	if input.LatB != nil {
		q = append(q, bson.E{"lat", bson.D{{"$lt", input.LatB}}})
	}
	if input.LonA != nil {
		q = append(q, bson.E{"lon", bson.D{{"$gt", input.LonA}}})
	}
	if input.LonB != nil {
		q = append(q, bson.E{"lon", bson.D{{"$lt", input.LonB}}})
	}
	if input.Type != nil && len(input.Type) > 0 {
		types := make([]string, len(input.Type))
		for i := range input.Type {
			types[i] = *input.Type[i]
		}
		q = append(q, bson.E{"type", bson.D{{"$in", types}}})
	}
	// Filter by substring name
	// if input.Name != nil && *input.Name != "" {
	// 	strName := primitive.Regex{Pattern: fmt.Sprintf("%v", *input.Name), Options: "i"}
	// 	q = append(q, bson.E{"name", bson.D{{"$regex", strName}}})
	// 	fmt.Println("q:", q)
	// }

	if input.Name != nil && *input.Name != "" {
		var allAllowOpts []model.Nodedata
		fmt.Println("Filter by name=================>>>>>")

		aggregateQuery := []bson.M{}

		strName := primitive.Regex{Pattern: fmt.Sprintf("^%v", *input.Name), Options: "i"}
		fmt.Println("strName: ", strName)
		aggregateQuery = append(aggregateQuery, bson.M{"$match": bson.M{"data.value": bson.D{{"$regex", strName}}}})
		// aggregateQuery = append(aggregateQuery,
		// 	bson.M{"$lookup": bson.M{
		// 		"from":         "tag",
		// 		"as":           "tagg",
		// 		"foreignField": "tag_id",
		// 		"localField":   "_id",
		// 	},
		// 	})
		cur, err := r.DB.Collection(repository.TblNodedata).Aggregate(ctx, aggregateQuery)
		if err != nil {
			return results, err
		}
		if er := cur.All(ctx, &allAllowOpts); er != nil {
			return results, er
		}
		fmt.Println("len=", len(allAllowOpts))

		IDs := []primitive.ObjectID{}
		for e := range allAllowOpts {
			IDs = append(IDs, allAllowOpts[e].NodeID)
		}

		fmt.Println("IDs len=", len(IDs))
		fmt.Println("Filter by name<<<<<=================")

		q = append(q, bson.E{"_id", bson.D{{"$in", IDs}}})
		//fmt.Println("q=", q)
	}

	pipe := mongo.Pipeline{}
	pipe = append(pipe, bson.D{{"$match", q}})
	if skip != nil {
		pipe = append(pipe, bson.D{{"$skip", skip}})
	}
	if limit != nil {
		pipe = append(pipe, bson.D{{"$limit", limit}})
	}

	var allItems []model.Node
	cursor, err := r.DB.Collection(repository.TblNode).Aggregate(ctx, pipe) //Aggregate(ctx, pipe) // Find(ctx, q, options)
	if err != nil {
		return results, err
	}
	defer cursor.Close(ctx)

	if er := cursor.All(ctx, &allItems); er != nil {
		return results, er
	}

	if len(allItems) == 0 {
		return results, nil
	}

	data := make([]*model.Node, len(allItems))
	for i, _ := range allItems {

		data[i] = &allItems[i]
	}

	total := 0
	results = &model.PaginationNode{
		Total: &total,
		Data:  data,
		Limit: limit,
		Skip:  skip,
	}

	return results, nil
}

// Osm is the resolver for the osm field.
func (r *queryResolver) Osm(ctx context.Context, first *int, after *string, limit *int, skip *int, lonA *float64, latA *float64, lonB *float64, latB *float64) ([]*model.Node, error) {
	var results []*model.Node

	options := options.Find()
	options.SetSort(bson.D{{"createdAt", 1}})
	if limit != nil {
		options.SetLimit(int64(*limit))
	}
	options.SetSkip(int64(*skip))
	q := bson.D{}
	if after != nil {
		// idPrimitive, err := primitive.ObjectIDFromHex(*after)
		// if err != nil {
		// 	return results, err
		// }

		// q = append(q, bson.E{"_id", bson.D{{"$lt", idPrimitive}}})
		// q = append(q, bson.E{"createdAt", bson.D{{"$lt", &after}}})
	}

	if latA != nil {
		q = append(q, bson.E{"lat", bson.D{{"$gt", latA}}})
	}
	if latB != nil {
		q = append(q, bson.E{"lat", bson.D{{"$lt", latB}}})
	}
	if lonA != nil {
		q = append(q, bson.E{"lon", bson.D{{"$gt", lonA}}})
	}
	if lonB != nil {
		q = append(q, bson.E{"lon", bson.D{{"$lt", lonB}}})
	}

	var allItems []model.Node
	cursor, err := r.DB.Collection(repository.TblNode).Find(ctx, q, options)
	if err != nil {
		return results, err
	}
	defer cursor.Close(ctx)

	if er := cursor.All(ctx, &allItems); er != nil {
		return results, er
	}

	if len(allItems) == 0 {
		return results, nil
	}

	for i, _ := range allItems {
		results = append(results, &allItems[i])
	}

	return results, nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id *string, osmID *string) (*model.Node, error) {
	var result *model.Node

	filter := bson.D{}
	if id != nil {
		userIDPrimitive, err := primitive.ObjectIDFromHex(*id)
		if err != nil {
			return result, err
		}

		filter = append(filter, bson.E{"_id", userIDPrimitive})
	} else if osmID != nil {
		filter = append(filter, bson.E{"osm_id", osmID})
	}

	if err := r.DB.Collection(repository.TblNode).FindOne(ctx, filter).Decode(&result); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return result, model.ErrNodeNotFound
		}
		return result, err
	}
	return result, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Node returns generated.NodeResolver implementation.
func (r *Resolver) Node() generated.NodeResolver { return &nodeResolver{r} }

type mutationResolver struct{ *Resolver }
type nodeResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *nodeResolver) P(ctx context.Context, obj *model.Node) (*string, error) {
	res := fmt.Sprintf("%v,%v,%v,%v", obj.OsmID, obj.Lat, obj.Lon, obj.Type)
	return &res, nil
}
func (r *nodeResolver) F(ctx context.Context, obj *model.Node) (*string, error) {
	// // gc, err := utils.GinContextFromContext(ctx)
	// // lang := gc.MustGet("i18nLocale").(string)
	// // if err != nil {
	// // 	return nil, err
	// // }
	// // listIDs := []primitive.ObjectID{}

	// // for i := range obj.Tags {
	// // 	uIDPrimitive, err := primitive.ObjectIDFromHex(obj.Tags[i])
	// // 	if err != nil {
	// // 		return []*int{}, err
	// // 	}
	// // 	listIDs = append(listIDs, uIDPrimitive)
	// // }
	// res, errs := loaders.GetTags(ctx, obj.Tags)
	// if len(errs) > 0 {
	// 	fmt.Println("Error:", len(obj.Tags), len(res))
	// }

	// // result, err := r.Repo.Tag.GqlGetTags(domain.RequestParams{
	// // 	Options: domain.Options{Limit: 10},
	// // 	Filter:  bson.M{"_id": bson.M{"$in": listIDs}},
	// // 	Lang:    lang,
	// // })
	// // if err != nil {
	// // 	return []*int{}, err
	// // }

	resultArray := []string{}
	// TODO
	// for i := range res {
	// 	// fmt.Println(i, res[i].Filter)
	// 	d := res[i].Filter
	// 	resultArray = append(resultArray, strconv.Itoa(d))
	// }

	resultString := strings.Join(resultArray, ".")
	return &resultString, nil
}
func (r *nodeResolver) Tags(ctx context.Context, obj *model.Node) ([]*string, error) {
	panic(fmt.Errorf("not implemented: Tags - tags"))
}
func (r *nodeResolver) Ilike(ctx context.Context, obj *model.Node) (*model.Like, error) {
	gc, err := utils.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}
	userID, err := middleware.GetUID(gc)
	if err != nil {
		return nil, err
	}
	ilike, err := r.Repo.Like.GqlGetIamLike(userID, obj.ID.Hex())
	if err != nil {
		return nil, err
	}
	return ilike, nil
}
