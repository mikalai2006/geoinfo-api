package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"

	"github.com/mikalai2006/geoinfo-api/graph/generated"
	"github.com/mikalai2006/geoinfo-api/graph/model"
	"github.com/mikalai2006/geoinfo-api/internal/domain"
	"github.com/mikalai2006/geoinfo-api/internal/repository"
	"github.com/mikalai2006/geoinfo-api/internal/utils"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

// Groups is the resolver for the groups field.
func (r *groupNodeDataResolver) Groups(ctx context.Context, obj *model.GroupNodeData) (any, error) {
	return obj.Groups, nil
}

// ID is the resolver for the _id field.
func (r *nodedataResolver) ID(ctx context.Context, obj *model.Nodedata) (string, error) {
	return obj.ID.Hex(), nil
}

// UserID is the resolver for the userId field.
func (r *nodedataResolver) UserID(ctx context.Context, obj *model.Nodedata) (string, error) {
	return obj.UserID.Hex(), nil
}

// NodeID is the resolver for the nodeId field.
func (r *nodedataResolver) NodeID(ctx context.Context, obj *model.Nodedata) (string, error) {
	return obj.NodeID.Hex(), nil
}

// TagID is the resolver for the tagId field.
func (r *nodedataResolver) TagID(ctx context.Context, obj *model.Nodedata) (string, error) {
	return obj.TagID.Hex(), nil
}

// TagoptID is the resolver for the tagoptId field.
func (r *nodedataResolver) TagoptID(ctx context.Context, obj *model.Nodedata) (string, error) {
	return obj.TagoptID.Hex(), nil
}

// Value is the resolver for the value field.
func (r *nodedataResolver) Value(ctx context.Context, obj *model.Nodedata) (any, error) {
	return obj.Data.Value, nil
}

// Locale is the resolver for the locale field.
func (r *nodedataResolver) Locale(ctx context.Context, obj *model.Nodedata) (any, error) {
	panic(fmt.Errorf("not implemented: Locale - locale"))
}

// Nodedatas is the resolver for the nodedatas field.
func (r *queryResolver) Nodedatas(ctx context.Context, first *int, after *string, limit *int, skip *int, input *model.FetchNodedata) (*model.PaginationNodedata, error) {
	var results *model.PaginationNodedata

	filter := bson.D{}
	if input.NodeID != nil {
		nID, _ := primitive.ObjectIDFromHex(*input.NodeID)
		filter = append(filter, bson.E{"node_id", nID})
	}
	if input.TagID != nil {
		tID, _ := primitive.ObjectIDFromHex(*input.TagID)
		filter = append(filter, bson.E{"tag_id", tID})
	}

	allItems, err := r.Repo.Nodedata.GqlGetNodedatas(domain.RequestParams{
		Options: domain.Options{Limit: int64(*limit)},
		Filter:  filter,
	})
	if err != nil {
		return results, err
	}

	data := make([]*model.Nodedata, len(allItems))
	for i, _ := range allItems {
		data[i] = allItems[i]
	}

	total := len(data)

	results = &model.PaginationNodedata{
		Data:  data,
		Total: &total,
		Limit: limit,
		Skip:  skip,
	}

	return results, nil
}

// GroupNodeData is the resolver for the groupNodeData field.
func (r *queryResolver) GroupNodeData(ctx context.Context) (*model.GroupNodeData, error) {
	var result *model.GroupNodeData

	pipe := mongo.Pipeline{}

	pipe = append(pipe, bson.D{{"$group", bson.M{"_id": bson.D{{"$toString", "$tagopt_id"}}, "count": bson.M{"$sum": 1}}}})

	var allItems []map[string]interface{}
	cursor, err := r.DB.Collection(repository.TblNodedata).Aggregate(ctx, pipe)
	if err != nil {
		return result, err
	}
	defer cursor.Close(ctx)

	if er := cursor.All(ctx, &allItems); er != nil {
		return result, er
	}

	fmt.Println(allItems)
	// result = &model.GroupNodeData{
	// 	Groups: allItems,
	// }

	return result, nil
}

// Nodedata is the resolver for the nodedata field.
func (r *queryResolver) Nodedata(ctx context.Context, id *string) (*model.Nodedata, error) {
	var result *model.Nodedata

	// filter := bson.D{}
	var pipe mongo.Pipeline
	if id != nil {
		IDPrimitive, err := primitive.ObjectIDFromHex(*id)
		if err != nil {
			return result, err
		}

		// filter = append(filter, bson.E{"_id", IDPrimitive})
		pipe = append(pipe, bson.D{{"$match", bson.M{"_id": IDPrimitive}}})
		pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
			"from": "users",
			"as":   "userb",
			"let":  bson.D{{Key: "userId", Value: "$user_id"}},
			"pipeline": mongo.Pipeline{
				bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$_id", "$$userId"}}}}},
				bson.D{{"$limit", 1}},
				bson.D{{
					Key: "$lookup",
					Value: bson.M{
						"from": "image",
						"as":   "images",
						"let":  bson.D{{Key: "serviceId", Value: bson.D{{"$toString", "$_id"}}}},
						"pipeline": mongo.Pipeline{
							bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$service_id", "$$serviceId"}}}}},
						},
					},
				}},
			},
		}}})
		pipe = append(pipe, bson.D{{Key: "$set", Value: bson.M{"user": bson.M{"$first": "$userb"}}}})

		pipe = append(pipe, bson.D{{Key: "$lookup", Value: bson.M{
			"from": "nodedata_vote",
			"as":   "votes",
			"let":  bson.D{{Key: "id", Value: "$_id"}},
			"pipeline": mongo.Pipeline{
				bson.D{{Key: "$match", Value: bson.M{"$expr": bson.M{"$eq": [2]string{"$nodedata_id", "$$id"}}}}},
			},
		}}})

	}

	// if err := r.DB.Collection(repository.TblNodedata).FindOne(ctx, filter).Decode(&result); err != nil {
	// 	if errors.Is(err, mongo.ErrNoDocuments) {
	// 		return result, model.ErrTagOptNotFound
	// 	}
	// 	return result, err
	// }
	cursor, err := r.DB.Collection(repository.TblNodedata).Aggregate(ctx, pipe)
	if err != nil {
		return result, err
	}
	defer cursor.Close(ctx)

	if cursor.Next(ctx) {
		if er := cursor.Decode(&result); er != nil {
			return result, er
		}
	}
	return result, nil
}

// GroupNodeData returns generated.GroupNodeDataResolver implementation.
func (r *Resolver) GroupNodeData() generated.GroupNodeDataResolver { return &groupNodeDataResolver{r} }

// Nodedata returns generated.NodedataResolver implementation.
func (r *Resolver) Nodedata() generated.NodedataResolver { return &nodedataResolver{r} }

type groupNodeDataResolver struct{ *Resolver }
type nodedataResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *nodedataResolver) Tag(ctx context.Context, obj *model.Nodedata) (*model.Tag, error) {
	gc, err := utils.GinContextFromContext(ctx)
	lang := gc.MustGet("i18nLocale").(string)
	if err != nil {
		return nil, err
	}

	var result *model.Tag

	filter := bson.D{}

	filter = append(filter, bson.E{"_id", obj.TagID})

	params := domain.RequestParams{
		// Options: domain.Options{Limit: 10},
		Filter: filter,
		Lang:   lang,
	}
	results, err := r.Repo.Tag.FindTag(params)
	if len(results.Data) > 0 {
		result = &results.Data[0]
	}

	// if err := r.DB.Collection(repository.TblTag).FindOne(ctx, filter).Decode(&result); err != nil {
	// 	if errors.Is(err, mongo.ErrNoDocuments) {
	// 		return result, model.ErrTagNotFound
	// 	}
	// 	return result, err
	// }
	// var results []*model.Tag
	// cursor, err := r.DB.Collection(repository.TblTag).Aggregate(ctx, pipe)
	// if err != nil {
	// 	return result, err
	// }
	// defer cursor.Close(ctx)

	// if er := cursor.All(ctx, &results); er != nil {
	// 	return result, er
	// }

	return result, nil
}
func (r *nodedataResolver) Tagopt(ctx context.Context, obj *model.Nodedata) (*model.Tagopt, error) {
	gc, err := utils.GinContextFromContext(ctx)
	lang := gc.MustGet("i18nLocale").(string)
	if err != nil {
		return nil, err
	}

	var result *model.Tagopt

	filter := bson.D{}

	filter = append(filter, bson.E{"_id", obj.TagoptID})

	params := domain.RequestParams{
		// Options: domain.Options{Limit: 10},
		Filter: filter,
		Lang:   lang,
	}
	results, err := r.Repo.Tagopt.FindTagopt(params)
	if len(results.Data) > 0 {
		result = &results.Data[0]
	}

	return result, nil
}
func (r *nodedataResolver) Audit(ctx context.Context, obj *model.Nodedata) ([]*model.NodedataAudit, error) {
	panic(fmt.Errorf("not implemented: Audit - audit"))
}
func (r *nodedataResolver) CreatedAt(ctx context.Context, obj *model.Nodedata) (string, error) {
	return obj.CreatedAt.String(), nil
}
func (r *nodedataResolver) UpdatedAt(ctx context.Context, obj *model.Nodedata) (string, error) {
	return obj.UpdatedAt.String(), nil
}
func (r *nodedataResolver) User(ctx context.Context, obj *model.Nodedata) (*model.User, error) {
	var result *model.User
	gc, err := utils.GinContextFromContext(ctx)
	if err != nil {
		return result, err
	}
	lang := gc.MustGet("i18nLocale").(string)

	filter := bson.D{}
	filter = append(filter, bson.E{"_id", obj.UserID})

	allItems, err := r.Repo.User.GqlGetUsers(domain.RequestParams{
		Options: domain.Options{Limit: 1, Skip: 0},
		Filter:  filter,
		Lang:    lang,
	})
	if err != nil {
		return result, err
	}

	if len(allItems) > 0 {
		result = allItems[0]
	}

	return result, nil
}
