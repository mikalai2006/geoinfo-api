package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"

	"github.com/mikalai2006/geoinfo-api/graph/generated"
	"github.com/mikalai2006/geoinfo-api/graph/model"
	"github.com/mikalai2006/geoinfo-api/internal/domain"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// ReviewsConnection is the resolver for the reviewsConnection field.
func (r *queryResolver) ReviewsConnection(ctx context.Context, first *int, after *string, limit *int, skip *int, input *model.FetchReview) (*model.ReviewsConnection, error) {
	var results *model.ReviewsConnection

	// The cursor is base64 encoded by convention, so we need to decode it first
	// var decodedCursor string
	// if after != nil {
	// 	// b, err := primitive.ObjectIDFromHex(*after)
	// 	// if err != nil {
	// 	// 	return nil, err
	// 	// }
	// 	decodedCursor = *after //string(b)
	// }

	// count := 0
	// currentPage := false

	// if decodedCursor == "" {
	// 	currentPage = true
	// }
	hasNextPage := false

	// options := options.Find()
	// options.SetSort(bson.D{{"createdAt", 1}})
	// if limit != nil {
	// 	options.SetLimit(int64(*limit))
	// }
	// options.SetSkip(int64(*skip))
	// q := bson.D{}
	// if after != nil {
	// 	// idPrimitive, err := primitive.ObjectIDFromHex(*after)
	// 	// if err != nil {
	// 	// 	return results, err
	// 	// }

	// 	// q = append(q, bson.E{"_id", bson.D{{"$lt", idPrimitive}}})
	// 	// q = append(q, bson.E{"createdAt", bson.D{{"$lt", &after}}})
	// }

	// var allItems []model.Review
	// cursor, err := r.DB.Collection(repository.TblReview).Find(ctx, q, options)
	// if err != nil {
	// 	return results, err
	// }
	// defer cursor.Close(ctx)

	// if er := cursor.All(ctx, &allItems); er != nil {
	// 	return results, er
	// }

	// if len(allItems) == 0 {
	// 	return results, nil
	// }

	filter := bson.D{}
	if input.UserID != nil {
		userIDPrimitive, err := primitive.ObjectIDFromHex(*input.UserID)
		if err != nil {
			return results, err
		}

		filter = append(filter, bson.E{"user_id", userIDPrimitive})
	} else if input.OsmID != nil {
		filter = append(filter, bson.E{"osm_id", *input.OsmID})
	}

	allItems, err := r.Repo.Review.GqlGetReviews(domain.RequestParams{
		Options: domain.Options{Limit: int64(*limit), Sort: bson.D{bson.E{"created_at", -1}}},
		Filter:  filter,
	})
	if err != nil {
		return results, err
	}
	if len(allItems) == 0 {
		return results, err
	}

	edges := make([]*model.ReviewEdge, len(allItems))
	for i, _ := range allItems {

		edges[i] = &model.ReviewEdge{
			Cursor: allItems[i].ID.Hex(),
			Node:   allItems[i],
		}
	}

	// fetch only the required
	// part of data from the database
	// edges := make([]*model.NodeEdge, *first)
	// for i, _ := range allItems {
	// 	if allItems[i].CreatedAt.String() == decodedCursor {
	// 		currentPage = true
	// 	}

	// 	if currentPage && count < *first {
	// 		edges[count] = &model.NodeEdge{
	// 			Cursor: allItems[i].ID.Hex(),
	// 			Node:   &allItems[i],
	// 		}
	// 		count++
	// 	}

	// 	// If there are any elements left after the current page
	// 	// we indicate that in the response
	// 	if count == *first && i < len(allItems) {
	// 		hasNextPage = true
	// 	}
	// }

	// fmt.Println("NodesConnection decodedCursor=", decodedCursor, len(allItems))

	pageInfo := model.PageInfo{
		StartCursor: edges[0].Node.ID.Hex(),
		EndCursor:   edges[len(edges)-1].Node.ID.Hex(),
		// StartCursor: edges[0].Node.CreatedAt.String(),
		// EndCursor:   edges[count-1].Node.CreatedAt.String(),
		HasNextPage: &hasNextPage,
	}

	totalResults := model.ReviewsConnection{
		Edges:    edges,
		PageInfo: &pageInfo,
	}

	return &totalResults, nil
}

// Review is the resolver for the review field.
func (r *queryResolver) Review(ctx context.Context, input *model.FetchReview) (*model.Review, error) {
	var result *model.Review

	filter := bson.D{}
	if input.ID != nil {
		iDPrimitive, err := primitive.ObjectIDFromHex(*input.ID)
		if err != nil {
			return result, err
		}

		filter = append(filter, bson.E{"_id", iDPrimitive})
	}
	if input.OsmID != nil {
		filter = append(filter, bson.E{"osm_id", input.OsmID})
	}
	if input.UserID != nil {
		userIDPrimitive, err := primitive.ObjectIDFromHex(*input.UserID)
		if err != nil {
			return result, err
		}
		filter = append(filter, bson.E{"user_id", userIDPrimitive})
	}
	fmt.Println(filter)

	allItems, err := r.Repo.Review.GqlGetReviews(domain.RequestParams{
		Options: domain.Options{Limit: 1},
		Filter:  filter,
	})
	if err != nil {
		return result, err
	}
	if len(allItems) == 0 {
		return result, err
	}
	return allItems[0], err
	// if err := r.DB.Collection(repository.TblReview).FindOne(ctx, filter).Decode(&result); err != nil {
	// 	if errors.Is(err, mongo.ErrNoDocuments) {
	// 		return result, model.ErrReviewNotFound
	// 	}
	// 	return result, err
	// }
	// return result, nil
}

// ID is the resolver for the _id field.
func (r *reviewResolver) ID(ctx context.Context, obj *model.Review) (string, error) {
	return obj.ID.Hex(), nil
}

// UserID is the resolver for the userId field.
func (r *reviewResolver) UserID(ctx context.Context, obj *model.Review) (string, error) {
	return obj.UserID.Hex(), nil
}

// Review returns generated.ReviewResolver implementation.
func (r *Resolver) Review() generated.ReviewResolver { return &reviewResolver{r} }

type reviewResolver struct{ *Resolver }
